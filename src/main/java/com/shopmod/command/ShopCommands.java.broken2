package com.shopmod.command;

import com.mojang.brigadier.CommandDispatcher;
import com.mojang.brigadier.arguments.IntegerArgumentType;
import com.mojang.brigadier.arguments.StringArgumentType;
import com.mojang.brigadier.context.CommandContext;
import com.shopmod.ShopMod;
import com.shopmod.currency.CurrencyManager;
import com.shopmod.gui.ShopGui;
import com.shopmod.shop.ItemPricing;
import com.shopmod.shop.ShopTier;
import net.minecraft.commands.CommandSourceStack;
import net.minecraft.commands.Commands;
import net.minecraft.core.registries.BuiltInRegistries;
import net.minecraft.network.chat.Component;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.world.item.Item;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.item.Items;

/**
 * Registers all shop-related commands
 */
public class ShopCommands {
    
    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
        // /shop - Opens the shop GUI and subcommands
        dispatcher.register(Commands.literal("shop")
            .executes(ShopCommands::openShop)
            .then(Commands.literal("balance")
                .executes(ShopCommands::showBalance))
            .then(Commands.literal("buy")
                .then(Commands.argument("item", StringArgumentType.word())
                    .executes(ctx -> buyItem(ctx, 1))
                    .then(Commands.argument("amount", IntegerArgumentType.integer(1))
                        .executes(ctx -> buyItem(ctx, IntegerArgumentType.getInteger(ctx, "amount"))))))
            .then(Commands.literal("sell")
                .then(Commands.argument("item", StringArgumentType.word())
                    .executes(ctx -> sellItem(ctx, 1))
                    .then(Commands.argument("amount", IntegerArgumentType.integer(1))
                        .executes(ctx -> sellItem(ctx, IntegerArgumentType.getInteger(ctx, "amount"))))))
            .then(Commands.literal("tiers")
                .executes(ShopCommands::showTiers))
            .then(Commands.literal("unlock")
                .then(Commands.argument("tier", StringArgumentType.word())
                    .executes(ShopCommands::unlockTier)))
        );
        
        // /sell - Quick sell item in hand
        dispatcher.register(Commands.literal("sell")
            .executes(ShopCommands::sellItemInHand)
            .then(Commands.argument("amount", IntegerArgumentType.integer(1))
                .executes(ctx -> sellItemInHand(ctx, IntegerArgumentType.getInteger(ctx, "amount"))))
        );
        
        // /balance or /bal - Quick balance check
        dispatcher.register(Commands.literal("balance")
            .executes(ShopCommands::showBalance));
            
        dispatcher.register(Commands.literal("bal")
            .executes(ShopCommands::showBalance));
            
        // Admin commands for testing
        dispatcher.register(Commands.literal("shopadmin")
            .requires(source -> {
                try {
                    return source.hasPermission(2);
                } catch (Exception e) {
                    return true; // Fallback for compatibility
                }
            })
            .then(Commands.literal("setmoney")
                .then(Commands.argument("amount", IntegerArgumentType.integer(0))
                    .executes(ShopCommands::setMoney)))
            .then(Commands.literal("addmoney")
                .then(Commands.argument("amount", IntegerArgumentType.integer(0))
                    .executes(ShopCommands::addMoney)))
        );
    }
    
    private static int openShop(CommandContext<CommandSourceStack> context) {
        try {
            ServerPlayer player = context.getSource().getPlayerOrException();
            ShopGui gui = new ShopGui(player);
            gui.open();
            return 1;
        } catch (Exception e) {
            context.getSource().sendFailure(Component.literal("Failed to open shop: " + e.getMessage()));
            e.printStackTrace();
            return 0;
        }
    }
    
    private static int showBalance(CommandContext<CommandSourceStack> context) {
        try {
            ServerPlayer player = context.getSource().getPlayerOrException();
            CurrencyManager.sendBalanceMessage(player);
            return 1;
        } catch (Exception e) {
            return 0;
        }
    }
    
    private static int buyItem(CommandContext<CommandSourceStack> context, int amount) {
        try {
            ServerPlayer player = context.getSource().getPlayerOrException();
            String itemName = StringArgumentType.getString(context, "item");
            
            // Try to find the item
            ResourceLocation loc = ResourceLocation.tryParse(itemName);
            if (loc == null) {
                loc = ResourceLocation.tryParse("minecraft:" + itemName);
            }
            Item item = loc != null ? BuiltInRegistries.ITEM.get(loc) : Items.AIR;
            
            if (item == null || item == Items.AIR) {
                player.sendSystemMessage(Component.literal("§cItem not found: " + itemName));
                return 0;
            }
            
            // Check if item is available for purchase
            ShopTier tier = ItemPricing.getTier(item);
            if (tier == null) {
                player.sendSystemMessage(Component.literal("§cThis item cannot be purchased."));
                return 0;
            }
            
            // Check if player has unlocked the tier
            if (!ShopMod.dataManager.hasTierUnlocked(player.getUUID(), tier.getId())) {
                player.sendSystemMessage(Component.literal("§cYou need to unlock " + tier.getColor() + tier.getName() + "§c tier first!"));
                return 0;
            }
            
            // Get price and calculate total
            long unitPrice = ItemPricing.getBuyPrice(item);
            long totalPrice = unitPrice * amount;
            
            // Check if player can afford it
            if (!CurrencyManager.canAfford(player, totalPrice)) {
                CurrencyManager.sendInsufficientFundsMessage(player, totalPrice);
                return 0;
            }
            
            // Process purchase
            if (CurrencyManager.removeMoney(player, totalPrice)) {
                ItemStack stack = new ItemStack(item, amount);
                player.addItem(stack);
                
                player.sendSystemMessage(Component.literal("§aPurchased §f" + amount + "x " + 
                    item.getName(stack).getString() + " §afor " + CurrencyManager.format(totalPrice)));
                CurrencyManager.sendBalanceMessage(player);
                return 1;
            }
            
            return 0;
        } catch (Exception e) {
            context.getSource().sendFailure(Component.literal("Error buying item: " + e.getMessage()));
            e.printStackTrace();
            return 0;
        }
    }
    
    private static int sellItem(CommandContext<CommandSourceStack> context, int amount) {
        try {
            ServerPlayer player = context.getSource().getPlayerOrException();
            String itemName = StringArgumentType.getString(context, "item");
            
            // Try to find the item
            ResourceLocation loc = ResourceLocation.tryParse(itemName);
            if (loc == null) {
                loc = ResourceLocation.tryParse("minecraft:" + itemName);
            }
            Item item = loc != null ? BuiltInRegistries.ITEM.get(loc) : Items.AIR;
            
            if (item == null || item == Items.AIR) {
                player.sendSystemMessage(Component.literal("§cItem not found: " + itemName));
                return 0;
            }
            
            // Check if item can be sold
            if (!ItemPricing.canSell(item)) {
                player.sendSystemMessage(Component.literal("§cThis item cannot be sold."));
                return 0;
            }
            
            // Count how many the player has
            int available = 0;
            for (int i = 0; i < player.getInventory().getContainerSize(); i++) {
                ItemStack stack = player.getInventory().getItem(i);
                if (stack.is(item)) {
                    available += stack.getCount();
                }
            }
            
            if (available < amount) {
                player.sendSystemMessage(Component.literal("§cYou only have " + available + "x " + item.getName(new ItemStack(item)).getString()));
                return 0;
            }
            
            // Calculate sell price
            long unitPrice = ItemPricing.getSellPrice(item);
            long totalPrice = unitPrice * amount;
            
            // Remove items from inventory
            int remaining = amount;
            for (int i = 0; i < player.getInventory().getContainerSize(); i++) {
                if (remaining <= 0) break;
                ItemStack stack = player.getInventory().getItem(i);
                if (stack.is(item)) {
                    int toRemove = Math.min(remaining, stack.getCount());
                    stack.shrink(toRemove);
                    remaining -= toRemove;
                }
            }
            
            // Add money
            CurrencyManager.addMoney(player, totalPrice);
            
            player.sendSystemMessage(Component.literal("§aSold §f" + amount + "x " + 
                item.getName(new ItemStack(item)).getString() + " §afor " + CurrencyManager.format(totalPrice)));
            CurrencyManager.sendBalanceMessage(player);
            return 1;
            
        } catch (Exception e) {
            context.getSource().sendFailure(Component.literal("Error selling item: " + e.getMessage()));
            e.printStackTrace();
            return 0;
        }
    }
    
    private static int sellItemInHand(CommandContext<CommandSourceStack> context) {
        return sellItemInHand(context, 1);
    }
    
    private static int sellItemInHand(CommandContext<CommandSourceStack> context, int amount) {
        try {
            ServerPlayer player = context.getSource().getPlayerOrException();
            ItemStack heldStack = player.getMainHandItem();
            
            if (heldStack.isEmpty()) {
                player.sendSystemMessage(Component.literal("§cYou're not holding anything!"));
                return 0;
            }
            
            Item item = heldStack.getItem();
            
            // Check if item can be sold
            if (!ItemPricing.canSell(item)) {
                player.sendSystemMessage(Component.literal("§cThis item cannot be sold."));
                return 0;
            }
            
            // Count how many the player has
            int available = 0;
            for (int i = 0; i < player.getInventory().getContainerSize(); i++) {
                ItemStack stack = player.getInventory().getItem(i);
                if (stack.is(item)) {
                    available += stack.getCount();
                }
            }
            
            int toSell = Math.min(amount, available);
            if (toSell <= 0) {
                player.sendSystemMessage(Component.literal("§cYou don't have any to sell!"));
                return 0;
            }
            
            // Calculate sell price
            long unitPrice = ItemPricing.getSellPrice(item);
            long totalPrice = unitPrice * toSell;
            
            // Remove items from inventory
            int remaining = toSell;
            for (int i = 0; i < player.getInventory().getContainerSize(); i++) {
                if (remaining <= 0) break;
                ItemStack stack = player.getInventory().getItem(i);
                if (stack.is(item)) {
                    int toRemove = Math.min(remaining, stack.getCount());
                    stack.shrink(toRemove);
                    remaining -= toRemove;
                }
            }
            
            // Add money
            CurrencyManager.addMoney(player, totalPrice);
            
            player.sendSystemMessage(Component.literal("§aSold §f" + toSell + "x " + 
                item.getName(new ItemStack(item)).getString() + " §afor " + CurrencyManager.format(totalPrice)));
            CurrencyManager.sendBalanceMessage(player);
            return 1;
            
        } catch (Exception e) {
            context.getSource().sendFailure(Component.literal("Error selling item: " + e.getMessage()));
            e.printStackTrace();
            return 0;
        }
    }
    
    private static int showTiers(CommandContext<CommandSourceStack> context) {
        try {
            ServerPlayer player = context.getSource().getPlayerOrException();
            
            player.sendSystemMessage(Component.literal("§6=== Shop Tiers ==="));
            
            for (ShopTier tier : ShopTier.values()) {
                boolean unlocked = ShopMod.dataManager.hasTierUnlocked(player.getUUID(), tier.getId());
                String status = unlocked ? "§a✓ Unlocked" : "§c✗ Locked";
                String cost = tier.getUnlockCost() == 0 ? "FREE" : CurrencyManager.format(tier.getUnlockCost());
                
                player.sendSystemMessage(Component.literal(
                    tier.getColor() + tier.getName() + " §7(" + cost + ") " + status
                ));
            }
            
            player.sendSystemMessage(Component.literal("§7Use §f/shop unlock <tier>§7 to unlock new tiers"));
            return 1;
            
        } catch (Exception e) {
            context.getSource().sendFailure(Component.literal("Error showing tiers: " + e.getMessage()));
            return 0;
        }
    }
    
    private static int unlockTier(CommandContext<CommandSourceStack> context) {
        try {
            ServerPlayer player = context.getSource().getPlayerOrException();
            String tierName = StringArgumentType.getString(context, "tier").toUpperCase();
            
            // Find the tier
            ShopTier tier = null;
            for (ShopTier t : ShopTier.values()) {
                if (t.getName().toUpperCase().replace(" ", "_").equals(tierName) || 
                    t.getName().toUpperCase().replace(" ", "").equals(tierName)) {
                    tier = t;
                    break;
                }
            }
            
            if (tier == null) {
                player.sendSystemMessage(Component.literal("§cTier not found. Available tiers: FARMER, ENGINEER, MERCHANT, NETHER_MASTER, ELITE"));
                return 0;
            }
            
            // Check if already unlocked
            if (ShopMod.dataManager.hasTierUnlocked(player.getUUID(), tier.getId())) {
                player.sendSystemMessage(Component.literal("§eYou already have " + tier.getColor() + tier.getName() + " §etier unlocked!"));
                return 0;
            }
            
            // Check if can unlock (must unlock in order)
            if (tier.getId() > 0) {
                ShopTier previousTier = ShopTier.getById(tier.getId() - 1);
                if (!ShopMod.dataManager.hasTierUnlocked(player.getUUID(), previousTier.getId())) {
                    player.sendSystemMessage(Component.literal("§cYou must unlock " + previousTier.getColor() + 
                        previousTier.getName() + " §ctier first!"));
                    return 0;
                }
            }
            
            // Check if player can afford it
            long cost = tier.getUnlockCost();
            if (!CurrencyManager.canAfford(player, cost)) {
                CurrencyManager.sendInsufficientFundsMessage(player, cost);
                return 0;
            }
            
            // Purchase tier
            if (CurrencyManager.removeMoney(player, cost)) {
                ShopMod.dataManager.unlockTier(player.getUUID(), tier.getId());
                player.sendSystemMessage(Component.literal("§a✓ Unlocked " + tier.getColor() + tier.getName() + " §atier!"));
                CurrencyManager.sendBalanceMessage(player);
                return 1;
            }
            
            return 0;
            
        } catch (Exception e) {
            context.getSource().sendFailure(Component.literal("Error unlocking tier: " + e.getMessage()));
            e.printStackTrace();
            return 0;
        }
    }
    
    private static int setMoney(CommandContext<CommandSourceStack> context) {
        try {
            ServerPlayer player = context.getSource().getPlayerOrException();
            int amount = IntegerArgumentType.getInteger(context, "amount");
            
            long current = CurrencyManager.getBalance(player);
            if (amount > current) {
                CurrencyManager.addMoney(player, amount - current);
            } else if (amount < current) {
                CurrencyManager.removeMoney(player, current - amount);
            }
            
            player.sendSystemMessage(Component.literal("Balance set to " + CurrencyManager.format(amount)));
            return 1;
        } catch (Exception e) {
            return 0;
        }
    }
    
    private static int addMoney(CommandContext<CommandSourceStack> context) {
        try {
            ServerPlayer player = context.getSource().getPlayerOrException();
            int amount = IntegerArgumentType.getInteger(context, "amount");
            
            CurrencyManager.addMoney(player, amount);
            player.sendSystemMessage(Component.literal("Added " + CurrencyManager.format(amount) + " to balance"));
            CurrencyManager.sendBalanceMessage(player);
            return 1;
        } catch (Exception e) {
            return 0;
        }
    }
}
